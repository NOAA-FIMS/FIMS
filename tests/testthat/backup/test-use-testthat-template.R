# Instructions ----
#' This file follows the format generated by FIMS:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?FIMS:::use_testthat_template` for more
#' information. Every test should have a @description tag that takes up just
#' one line, which will be used in the bookdown report of {testthat} results.


# use_testthat_template ----
## setup ----
# Create temporary files for testing purposes
create_temporary_file <- function(temp_path) {
  # Create the directory for the temporary package
  dir.create(temp_path)
  # Save the current working directory and set the new one for the temporary
  # package
  old_wd <- getwd()
  setwd(temp_path)
  # Ensure that the working directory is reset after the function exits
  on.exit(setwd(old_wd), add = TRUE)
  # Create a new package at the specified path
  pkg <- suppressMessages(
    invisible(capture.output(
      usethis::create_package(temp_path),
      type = "output"
    ))
  )

  suppressMessages(usethis::proj_set(temp_path))
  suppressMessages(usethis::use_testthat())
  suppressMessages(FIMS:::use_testthat_template("individual_function"))
  suppressMessages(FIMS:::use_testthat_template("function-group"))

  # Attempt to use the test template again inside a tryCatch to capture any
  # potential errors
  error <- tryCatch(FIMS:::use_testthat_template("individual_function"),
    error = function(e) {
      # Return a custom error message if an error occurs
      "An error occurred."
    }
  )
  # Return details about the created package, including paths and any errors
  output <- list(
    folder_path = temp_path,
    individual_function_path = file.path(
      temp_path, "tests", "testthat", "test-individual_function.R"
    ),
    function_group_path = file.path(
      temp_path, "tests", "testthat", "test-function-group.R"
    ),
    error = error
  )
}

# Generate temporary files for testing
temp_path <- file.path(tempdir(), "rcmdcheck")
unlink(temp_path, recursive = TRUE, force = TRUE)
output <- create_temporary_file(temp_path)
# Ensure the temporary folder is cleaned up after tests are complete
on.exit(unlink(output[["folder_path"]], recursive = TRUE, force = TRUE), add = TRUE)
on.exit(unlink(temp_path))

## IO correctness ----
test_that("use_testthat_template() works with correct inputs", {
  #' @description Test that use_testthat_template("individual_function") creates the correct file.
  expect_true(file.exists(output[["individual_function_path"]]))

  #' @description Test that use_testthat_template("function-group") creates the correct file.
  expect_true(file.exists(output[["function_group_path"]]))
})

## Edge handling ----
test_that("use_testthat_template() handles edge cases correctly", {
  #' @description Test that use_testthat_template() throws an error when no input is provided.
  expect_error(object = FIMS:::use_testthat_template())
})

## Error handling ----
test_that("use_testthat_template() throws an error if the file already exists", {
  #' @description Test that use_testthat_template("individual_function") throws an error when the file already exists.
  expect_equal(output[["error"]], "An error occurred.")
})
