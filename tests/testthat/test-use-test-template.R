# Instructions ----
#' This file follows the format generated by FIMS:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?FIMS:::use_gtest_template` for more
#' information. Every test should have a @description tag, which can span
#' multiple lines, that will be used in the bookdown report of the results from
#' {testthat}.


# use_*_template ----
## setup ----
# Set up for all of the use_*_template functions in the following section.

# Create a temporary package structure with the minimal files necessary for
# testing purposes in a temporary directory. And, ensure the temporary directory
# is cleaned up after the tests are complete.
temp_path <- file.path(tempdir(), "rcmdcheck")
# Must use showWarnings = FALSE or attempt to remove the directory before
# creating it because if you run this function more than once the directory will
# exist, though it will be empty.
dir.create(temp_path, showWarnings = FALSE)
on.exit(
  unlink(temp_path, recursive = TRUE, force = TRUE),
  add = TRUE
)
# Save the current working directory and set the new one for the temporary
# package but ensure that the working directory is reset at the end
old_wd <- getwd()
setwd(temp_path)
on.exit(setwd(old_wd), add = TRUE)
# Create a new package at the specified path
pkg <- suppressMessages(
  invisible(capture.output(
    usethis::create_package(temp_path),
    type = "output"
  ))
)
suppressMessages(usethis::proj_set(temp_path))
suppressMessages(usethis::use_testthat())
# Add a folder `gtest` for GoogleTest files
suppressMessages(usethis::use_directory(file.path("tests", "gtest")))
# Add a `CMakeLists.txt`` file in the `tests/gtest` directory
cmakelist_path <- file.path("tests", "gtest", "CMakeLists.txt")
file.create(cmakelist_path)

# use_gtest_template ----
## setup ----
# No additional setup is needed.

## IO correctness ----
test_that("use_gtest_template() works with correct inputs", {
  suppressMessages(FIMS:::use_gtest_template(
    name = "FIMSMath_ClassName_Logistic"
  ))
  #' @description Test that use_gtest_template() creates the correct test file.
  expect_true(file.exists(file.path(
    temp_path, "tests", "gtest", "test_FIMSMath_ClassName_Logistic.cpp"
  )))

  #' @description Test that use_gtest_template() creates the correct CMake file.
  expect_true(file.exists(file.path(temp_path, cmakelist_path)))

  # TODO: Make this test live by fixing the grepl statement
  suppressMessages(FIMS:::use_gtest_template(
    name = "FIMSMath_ClassName_FunctionName"
  ))

  # Search for the expected lines in the CMakeLists.txt file
  first_entry <- grepl(
    "test_FIMSMath_ClassName_Logistic.cpp",
    readLines(file.path(temp_path, cmakelist_path))
  )
  second_entry <- grepl(
    "test_FIMSMath_ClassName_FunctionName.cpp",
    readLines(file.path(temp_path, cmakelist_path))
  )
  #' @description Test that use_gtest_template() appends the correct lines to
  #' CMakeLists.txt when an additional test is added rather than writing over
  #' it.
  expect_true(any(first_entry))
  expect_true(any(second_entry))
  #' @description Test that use_gtest_template() appends the new test after the
  #' previous test in CMakeLists.txt.
  expect_gt(which(second_entry)[1], which(first_entry)[1])
})

## Edge handling ----
test_that("use_gtest_template() handles edge cases correctly", {
  #' @description Test that use_gtest_template() throws an error when format of name is wrong.
  expect_error(
    object = FIMS:::use_gtest_template(
      name = "ClassName_FunctionName"
    ),
    regexp = "Invalid `name` format"
  )
})

## Error handling ----
test_that("use_gtest_template() returns correct error messages", {
  #' @description Test that use_gtest_template() throws an error when the file
  #' already exists.
  error <- tryCatch(
    FIMS:::use_gtest_template(
      name = "FIMSMath_ClassName_Logistic"
    ),
    error = function(e) {
      # Return a custom error message if an error occurs
      "An error occurred."
    }
  )
  expect_equal(error, "An error occurred.")

  file.rename(
    from = file.path(temp_path, cmakelist_path),
    to = file.path(temp_path, "tests", "gtest", "renamed.txt")
  )
  #' @description Test that use_gtest_template() throws an error if the
  #' CMakeLists file does not already exist.
  expect_error(
    object = suppressMessages(FIMS:::use_gtest_template(
      name = "FIMSMath_ClassName_FunctionName"
    ))
  )
  file.rename(
    from = file.path(temp_path, "tests", "gtest", "renamed.txt"),
    to = file.path(temp_path, cmakelist_path)
  )
})

# use_testthat_template ----
## setup ----
# No additional setup is needed.

## IO correctness ----
test_that("use_testthat_template() works with correct inputs", {
  suppressMessages(FIMS:::use_testthat_template("individual_function"))
  #' @description Test that use_testthat_template("individual_function")
  #' creates the correct file.
  expect_true(file.exists(
    file.path(
      temp_path, "tests", "testthat", "test-individual_function.R"
    )
  ))

  suppressMessages(FIMS:::use_testthat_template("function-group"))
  #' @description Test that use_testthat_template("function-group") creates the
  #' correct file.
  expect_true(file.exists(
    file.path(
      temp_path, "tests", "testthat", "test-function-group.R"
    )
  ))
})

## Edge handling ----
test_that("use_testthat_template() handles edge cases correctly", {
  #' @description Test that use_testthat_template() throws an error when no input is provided.
  expect_error(object = FIMS:::use_testthat_template())
})

## Error handling ----
test_that("use_testthat_template() returns correct error messages", {
  # Attempt to use the test template again inside a tryCatch to capture any
  # potential errors
  error <- tryCatch(FIMS:::use_testthat_template("individual_function"),
    error = function(e) {
      # Return a custom error message if an error occurs
      "An error occurred."
    }
  )
  #' @description Test that use_testthat_template("individual_function") throws
  #' an error when the file already exists.
  expect_equal(error, "An error occurred.")
})
