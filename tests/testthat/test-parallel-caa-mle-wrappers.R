# Instructions ----
#' This file follows the format generated by FIMS:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?FIMS:::use_testthat_template` for more
#' information. Every test should have a @description tag, which can span
#' multiple lines, that will be used in the bookdown report of the results from
#' {testthat}.

# Run FIMS in serial and parallel ----
# This test demonstrates how to run the FIMS model in both serial and parallel
# modes. The parallel execution uses {snowfall} to parallelize the tasks across
# multiple CPU cores.

# Ensure the latest precompiled version of FIMS is installed in R before
# running devtools. To do this, either run:
# - devtools::install() followed by devtools::test(), or
# - devtools::check()

## Setup ----
# Skip the test if running on a local machine not in a CI environment
#' @description Skip the test if not running in a CI environment.
testthat::skip_if(!testthat:::env_var_is_true("CI"))

# TODO: don't skip the test on CI after resolving the failed parallel tests
testthat::skip_on_ci()

# Skip the test on CRAN and R-universe to avoid long runtimes
testthat::skip_on_cran()

# Skip this test if calculating code coverage
testthat::skip_on_covr()

# Load the model comparison operating model data from the fixtures folder
load(test_path("fixtures", "integration_test_data.RData"))

# Run 10 FIMS models
sim_num <- 10

# Run the FIMS model in serial and record the execution time
modified_parameters <- estimation_results_serial <- vector(mode = "list", length = sim_num)

for (i in 1:sim_num) {
  # Define modified parameters for different modules
  modified_parameters[[i]] <- list(
    fleet1 = list(
      Fleet.log_Fmort.value = log(om_output_list[[i]][["f"]])
    ),
    survey1 = list(
      LogisticSelectivity.inflection_point.value = 1.5,
      LogisticSelectivity.slope.value = 2,
      Fleet.log_q.value = log(1.0)
    ),
    recruitment = list(
      BevertonHoltRecruitment.log_rzero.value = log(om_input_list[[i]][["R0"]]),
      BevertonHoltRecruitment.log_devs.value = om_input_list[[i]][["logR.resid"]][-1],
      BevertonHoltRecruitment.log_devs.estimation_type = "constant",
      DnormDistribution.log_sd.value = om_input_list[[i]][["logR_sd"]]
    ),
    maturity = list(
      LogisticMaturity.inflection_point.value = om_input_list[[i]][["A50.mat"]],
      LogisticMaturity.inflection_point.estimation_type = "constant",
      LogisticMaturity.slope.value = om_input_list[[i]][["slope.mat"]],
      LogisticMaturity.slope.estimation_type = "constant"
    ),
    population = list(
      Population.log_init_naa.value = log(om_output_list[[i]][["N.age"]][1, ])
    )
  )

  estimation_results_serial[[i]] <- setup_and_run_FIMS_with_wrappers(
    iter_id = i,
    om_input_list = om_input_list,
    om_output_list = om_output_list,
    em_input_list = em_input_list,
    estimation_mode = TRUE,
    modified_parameters = modified_parameters
  )
}

## IO correctness ----
test_that("Run FIMS in parallel using {snowfall}", {
  core_num <- 2
  snowfall::sfInit(parallel = TRUE, cpus = core_num)

  snowfall::sfLibrary(FIMS)
  results_parallel <- snowfall::sfLapply(
    1:sim_num,
    setup_and_run_FIMS_with_wrappers,
    om_input_list,
    om_output_list,
    em_input_list,
    TRUE,
    FALSE,
    modified_parameters
  )

  snowfall::sfStop()

  # Comparison of results:
  # Verify that SSB values from both runs are equivalent.
  ssb_parallel <- purrr::map(
    results_parallel,
    \(x) x@estimates[x@estimates$label == "SSB", "estimated"]
  )

  ssb_serial <- purrr::map(
    estimation_results_serial,
    \(x) x@estimates[x@estimates$label == "SSB", "estimated"]
  )
  #' @description Test that SSB values from parallel runs equal those from serial runs.
  expect_setequal(ssb_parallel, ssb_serial)

  parameters_parallel <- purrr::map(
    results_parallel,
    \(x) x@estimates[x@estimates$label == "p", "estimated"]
  )
  parameters_serial <- purrr::map(
    estimation_results_serial,
    \(x) x@estimates[x@estimates$label == "p", "estimated"]
  )
  #' @description Test that parameter estimates from parallel runs equal those from serial runs.
  expect_setequal(parameters_parallel, parameters_serial)

  jnll_parallel <- purrr::map(
    results_parallel,
    \(x) x@report[["jnll"]]
  )
  jnll_serial <- purrr::map(
    estimation_results_serial,
    \(x) x@report[["jnll"]]
  )
  #' @description Test that total NLL values from parallel runs equal those from serial runs.
  expect_equal(jnll_parallel, jnll_serial)
})

## Edge handling ----
# No edge cases to test.

## Error handling ----
# No built-in errors to test.
