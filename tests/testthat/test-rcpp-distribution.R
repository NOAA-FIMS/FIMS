# Instructions ----
#' This file follows the format generated by FIMS:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?FIMS:::use_testthat_template` for more
#' information. Every test should have a @description tag, which can span
#' multiple lines, that will be used in the bookdown report of the results from
#' {testthat}.

# rcpp distribution ----
## Setup ----

# Load or prepare any necessary data for testing
## IO correctness ----
test_that("rcpp distribution works with correct inputs", {
  # generate data using R stats::rnorm
  set.seed(123)

  # simulate normal data with scalar input
  y <- stats::rnorm(1)
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- 0
  dnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test that dnorm works with a single value input, e.g. a prior on a parameter.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, 0, 1, TRUE))
  clear()

  # simulate normal data
  y <- stats::rnorm(10)
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dnorm_$x[x]$value <- y[x]
  )
  dnorm_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dnorm_$expected_values[x]$value <- 0
  )
  dnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test that dnorm works with a vector of state variables, but scalar arguments, e.g., a random effect vector.
  expect_equal(dnorm_$evaluate(), sum(stats::dnorm(y, 0, 1, TRUE)))
  clear()

  # simulate normal data
  y <- stats::rnorm(10)
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dnorm_$x[x]$value <- y[x]
  )
  dnorm_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dnorm_$expected_values[x]$value <- 0
  )
  dnorm_$log_sd$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dnorm_$log_sd[x]$value <- log(1)
  )
  # evaluate the density and compare with R
  #' @description Test that dnorm works with vectors of state variables (x) and arguments, e.g., an index likelihood vector.
  expect_equal(dnorm_$evaluate(), sum(stats::dnorm(y, 0, 1, TRUE)))
  clear()

  # generate data using R stats::rlnorm
  set.seed(123)
  # simulate lognormal data
  y <- stats::rlnorm(n = 1, meanlog = 0, sdlog = 1)

  # create a fims Rcpp object
  # initialize the Dlnorm module
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 0
  dlnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test that dlnorm works with a single value input, e.g. a prior on a parameter.
  expect_equal(dlnorm_$evaluate(), stats::dlnorm(y, 0, 1, TRUE))
  clear()

  y <- stats::rlnorm(n = 10, meanlog = 0, sdlog = 1)

  # create a fims Rcpp object
  # initialize the Dlnorm module
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$x[x]$value <- y[x]
  )
  dlnorm_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$expected_values[x]$value <- 0
  )
  dlnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test that dlnorm works with a vector of state variables, but scalar arguments, e.g., a random effect vector.
  expect_equal(dlnorm_$evaluate(), sum(stats::dlnorm(y, 0, 1, TRUE)))
  clear()

  y <- stats::rlnorm(n = 10, meanlog = 0, sdlog = 1)

  # create a fims Rcpp object
  # initialize the Dlnorm module
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$x[x]$value <- y[x]
  )
  dlnorm_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$expected_values[x]$value <- 0
  )
  dlnorm_$log_sd$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$log_sd[x]$value <- log(1)
  )
  # evaluate the density and compare with R
  #' @description Test that dlnorm with vectors of state variables (x) and arguments, e.g., an index likelihood vector.
  expect_equal(dlnorm_$evaluate(), sum(stats::dlnorm(y, 0, 1, TRUE)))
  clear()

 #' @description Test that dgamma works with a single value input,
  #' e.g. a prior on a parameter

  # generate data using R stats::rgamma
  set.seed(123)

  # simulate gamma data with scalar input
  # Using shape=4, scale=2 which gives mean=8, sd=4
  mean_val <- 8
  sd_val <- 4
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  
  y <- stats::rgamma(1, shape = shape_val, scale = scale_val)
  
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()

  #' @description Test that dgamma works with a vector of state variables,
  #' but scalar arguments, e.g., a random effect vector

  # simulate gamma data
  y <- stats::rgamma(10, shape = shape_val, scale = scale_val)
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$x[x]$value <- y[x]
  )
  dgamma_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$expected_values[x]$value <- mean_val
  )
  dgamma_$log_sd[1]$value <- log(sd_val)
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), sum(stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE)))
  clear()

  #' @description Test that dgamma works with vectors of state variables (x)
  #' and arguments, e.g., an index likelihood vector

  # simulate gamma data
  y <- stats::rgamma(10, shape = shape_val, scale = scale_val)
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$x[x]$value <- y[x]
  )
  dgamma_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$expected_values[x]$value <- mean_val
  )
  dgamma_$log_sd$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$log_sd[x]$value <- log(sd_val)
  )
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), sum(stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE)))
  clear()
})


  # generate data using R stats:rnorm
  set.seed(123)
  p <- (1:10) / sum(1:10)
  x_values <- t(stats::rmultinom(1, 100, p))
  # create a fims Rcpp object
  # initialize the Dmultinom module
  dmultinom_ <- methods::new(DmultinomDistribution)
  # populate class members
  dmultinom_$dims$resize(2)
  dmultinom_$dims$set(0, 1)
  dmultinom_$dims$set(1, length(p))
  dmultinom_$expected_values$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$expected_values[x]$value <- p[x]
  )

  dmultinom_$x$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$x[x]$value <- x_values[x]
  )

  # evaluate the density and compare with R
  #' @description Test that dmultinom works with vector inputs.
  expect_equal(
    dmultinom_$evaluate(),
    stats::dmultinom(x = x_values, prob = p, log = TRUE)
  )

  clear()
})

## Edge handling ----

test_that("rcpp_distribution returns correct outputs for edge cases", {
  set.seed(123)
  y <- -1000
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- 0
  dnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test extreme observed values for dnorm (-1000) return expected output.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, 0, 1, TRUE))
  clear()
  y <- 1000
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- 0
  dnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test extreme observed values for dnorm (1000) return expected output.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, 0, 1, TRUE))
  clear()

  y <- 1
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- -1000
  dnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test extreme expected values for dnorm (-1000) return expected output.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, -1000, 1, TRUE))
  clear()
  y <- 1
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- 1000
  dnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test extreme expected values for dnorm (1000) return expected output.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, 1000, 1, TRUE))
  clear()

  y <- 1
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- 0
  dnorm_$log_sd[1]$value <- 10
  # evaluate the density and compare with R
  #' @description Test extreme log_sd values for dnorm (10) return expected output.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, 0, exp(10), TRUE))
  clear()
  y <- 1
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x[1]$value <- y
  dnorm_$expected_values[1]$value <- 0
  dnorm_$log_sd[1]$value <- -10
  # evaluate the density and compare with R
  #' @description Test extreme log_sd values for dnorm (-10) return expected output.
  expect_equal(dnorm_$evaluate(), stats::dnorm(y, 0, exp(-10), TRUE))
  clear()

  y <- 0
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 0
  dlnorm_$log_sd[1]$value <- log(1)
  # evaluate the density and compare with R
  #' @description Test extreme observed values for dlnorm (0) return expected output.
  expect_equal(dlnorm_$evaluate(), NaN)
  clear()

  y <- -1
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 0
  dlnorm_$log_sd[1]$value <- log(1)
  #' @description Test extreme observed values for dlnorm (-1) return expected output.
  expect_equal(dlnorm_$evaluate(), NaN)
  clear()

  y <- 1000
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 0
  dlnorm_$log_sd[1]$value <- log(1)
  #' @description Test extreme observed values for dlnorm (1000) return expected output.
  expect_equal(dlnorm_$evaluate(), stats::dlnorm(y, 0, 1, TRUE))
  clear()

  y <- 1
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- -1000
  dlnorm_$log_sd[1]$value <- log(1)
  #' @description Test extreme expected values for dlnorm (-1000) return expected output.
  expect_equal(dlnorm_$evaluate(), stats::dlnorm(y, -1000, 1, TRUE))
  clear()
  y <- 1
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 1000
  dlnorm_$log_sd[1]$value <- log(1)
  #' @description Test extreme expected values for dlnorm (1000) return expected output.
  expect_equal(dlnorm_$evaluate(), -500000.92)
  clear()

  y <- 1
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 0
  dlnorm_$log_sd[1]$value <- 10
  #' @description Test extreme log_sd values for dlnorm (10) return expected output.
  expect_equal(dlnorm_$evaluate(), stats::dlnorm(y, 0, exp(10), TRUE))
  clear()
  y <- 1
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x[1]$value <- y
  dlnorm_$expected_values[1]$value <- 0
  dlnorm_$log_sd[1]$value <- -10
  #' @description Test extreme log_sd values for dlnorm (-10) return expected output.
  expect_equal(dlnorm_$evaluate(), 9.0810615)
  clear()

   set.seed(123)
  
  mean_val <- 8
  sd_val <- 4
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  
  #' @description Test extreme observed values for dgamma (0.001, 1000) return expected output.
  y <- 0.001
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()
  
  y <- 1000
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()

  #' @description Test extreme expected values for dgamma (0.1, 1000) return expected output.
  y <- 5
  mean_val <- 0.1
  sd_val <- 0.05
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()
  
  y <- 5
  mean_val <- 1000
  sd_val <- 500
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()

  #' @description Test extreme log_sd values for dgamma (-3, 3) return expected output.
  y <- 5
  mean_val <- 8
  sd_val <- exp(3)
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- 3
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()
  
  y <- 5
  mean_val <- 8
  sd_val <- exp(-3)
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- -3
  # evaluate the density and compare with R
  expect_equal(dgamma_$evaluate(), stats::dgamma(y, shape = shape_val, scale = scale_val, log = TRUE))
  clear()
  
  #' @description Test that dgamma returns -Inf for negative observed values
  y <- -1
  mean_val <- 8
  sd_val <- 4
  shape_val <- (mean_val / sd_val)^2
  scale_val <- (sd_val^2) / mean_val
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  expect_true(is.nan(dgamma_$evaluate()))
  clear()
  
  #' @description Test that dgamma returns -Inf for zero observed values
  y <- 0
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x[1]$value <- y
  dgamma_$expected_values[1]$value <- mean_val
  dgamma_$log_sd[1]$value <- log(sd_val)
  expect_equal(dgamma_$evaluate(), -Inf)
  clear()
})

  # generate data using R stats:rnorm
  p <- c(1, rep(0, 9))
  x_values <- t(stats::rmultinom(1, 1000, p))
  # create a fims Rcpp object
  # initialize the Dmultinom module
  dmultinom_ <- methods::new(DmultinomDistribution)
  # populate class members
  dmultinom_$dims$resize(2)
  dmultinom_$dims$set(0, 1)
  dmultinom_$dims$set(1, length(p))
  dmultinom_$expected_values$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$expected_values[x]$value <- p[x]
  )

  dmultinom_$x$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$x[x]$value <- x_values[x]
  )

  # evaluate the density and compare with R
  #' @description Test empty bins with large N (1000) in dmultinom return expected output.
  expect_equal(
    dmultinom_$evaluate(), NaN
  )
  clear()

  p <- c(1, rep(0, 9))
  x_values <- t(stats::rmultinom(1, 1, p))
  # create a fims Rcpp object
  # initialize the Dmultinom module
  dmultinom_ <- methods::new(DmultinomDistribution)
  # populate class members
  dmultinom_$dims$resize(2)
  dmultinom_$dims$set(0, 1)
  dmultinom_$dims$set(1, length(p))
  dmultinom_$expected_values$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$expected_values[x]$value <- p[x]
  )

  dmultinom_$x$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$x[x]$value <- x_values[x]
  )

  # evaluate the density and compare with R
  #' @description Test empty bins with small N (1) in dmultinom return expected output. generate data using R `stats:rnorm()`
  expect_equal(
    dmultinom_$evaluate(), NaN
  )
  clear()
})

## Error handling ----
test_that("rcpp distribution returns correct error messages", {
  y <- stats::rnorm(10)
  # create a fims Rcpp object
  # initialize the Dnorm module
  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dnorm_$x[x]$value <- y[x]
  )
  dnorm_$expected_values$resize(length(y) + 1)
  dnorm_$log_sd$resize(length(y))
  purrr::walk(
    seq_along(length(y)),
    \(x) dnorm_$expected_values[x]$value <- log(1)
  )
  #' @description dnorm should error out when there is a dimension mismatch where it is expecting `expected_values` to have a size 10 but is provided a size 11 vector.
  expect_error(
    object = dnorm_$evaluate(),
    regexp = "NormalLPDF::Vector .* out of bounds. .* 10 .* 11"
  )
  clear()

  dnorm_ <- methods::new(DnormDistribution)
  # populate class members
  dnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(dnorm_),
    \(x) dnorm_$x[x]$value <- y[x]
  )
  dnorm_$expected_values$resize(length(y))
  dnorm_$log_sd$resize(3)
  purrr::walk(
    1:3,
    \(x) dnorm_$log_sd[x]$value <- log(1)
  )
  #' @description dnorm should error out when there is a dimension mismatch where it is expecting `log_sd` to have a size 10 but is provided a size 3 vector.
  expect_error(
    object = dnorm_$evaluate(),
    regexp = "NormalLPDF::Vector .* out of bounds. .* 10 .* 3"
  )
  clear()

  y <- stats::rlnorm(n = 10, meanlog = 0, sdlog = 1)
  # create a fims Rcpp object
  # initialize the Dlnorm module
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$x[x]$value <- y[x]
  )
  dlnorm_$expected_values$resize(length(y) + 1)
  dlnorm_$log_sd$resize(length(y))
  purrr::walk(
    1:10,
    \(x) dlnorm_$log_sd[x]$value <- log(1)
  )
  # TODO: skip test until dimension checking is fixed in lognormal_lpdf.hpp
  # dlnorm should error out when there is a dimension mismatch
  # object <- dlnorm_$evaluate()
  # expected_error_message <- "LognormalLPDF::Vector .* out of bounds. .* 10 .* 11"
  # expect_error(object, expected_error_message)
  clear()

  # initialize the Dlnorm module
  dlnorm_ <- methods::new(DlnormDistribution)
  # populate class members
  dlnorm_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dlnorm_$x[x]$value <- y[x]
  )
  dlnorm_$expected_values$resize(length(y))
  dlnorm_$log_sd$resize(3)
  purrr::walk(
    1:3,
    \(x) dlnorm_$log_sd[x]$value <- log(1)
  )
  #' @description dlnorm should error out when there is a dimension mismatch where it is expecting log_sd to have a size 10 but is provided a size 3 vector.
  expect_error(
    object = dlnorm_$evaluate(),
    regexp = "LognormalLPDF::Vector .* out of bounds. .* 10 .* 3"
  )
  clear()

   #' @description dgamma should error out when there is a dimension mismatch
  #' where it is expecting log_sd to have a size 10
  #' but is provided a size 3 vector.
  y <- stats::rgamma(10, shape = 4, scale = 2)
  # create a fims Rcpp object
  # initialize the Dgamma module
  dgamma_ <- methods::new(DgammaDistribution)
  # populate class members
  dgamma_$x$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$x[x]$value <- y[x]
  )
  dgamma_$expected_values$resize(length(y))
  purrr::walk(
    seq_along(y),
    \(x) dgamma_$expected_values[x]$value <- 8
  )
  dgamma_$log_sd$resize(3)
  purrr::walk(
    1:3,
    \(x) dgamma_$log_sd[x]$value <- log(4)
  )
  expect_error(
    object = dgamma_$evaluate(),
    regexp = "GammaLPDF::Vector .* out of bounds. .* 10 .* 3"
  )
  clear()

  set.seed(123)
  p <- (1:12) / sum(1:12)
  x_values <- t(stats::rmultinom(1, 100, p))
  # create a fims Rcpp object
  # initialize the Dmultinom module
  dmultinom_ <- methods::new(DmultinomDistribution)
  # populate class members
  dmultinom_$dims$resize(2)
  dmultinom_$dims$set(0, 1)
  dmultinom_$dims$set(1, 10)
  dmultinom_$expected_values$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$expected_values[x]$value <- p[x]
  )
  dmultinom_$x$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$x[x]$value <- x_values[x]
  )
  #' @description dmultinom should error out when there is a dimension mismatch.
  expect_error(
    object = dmultinom_$evaluate(),
    regexp = "MultinomialLPDF: Vector index out of bounds. The dimension of the number of  rows times the number of columns is of size 10 and the observed vector is of size 12"
  )
  clear()

  set.seed(123)
  p <- (1:10) / sum(1:10)
  x_values <- t(stats::rmultinom(1, 100, p))
  # create a fims Rcpp object
  # initialize the Dmultinom module
  dmultinom_ <- methods::new(DmultinomDistribution)
  # populate class members
  dmultinom_$dims$resize(2)
  dmultinom_$dims$set(0, 1)
  dmultinom_$dims$set(1, 9)
  dmultinom_$expected_values$resize(length(p))
  purrr::walk(
    seq_along(p),
    \(x) dmultinom_$expected_values[x]$value <- p[x]
  )
  dmultinom_$x$resize(length(p) - 1)
  purrr::walk(
    seq_along(p[1:9]),
    \(x) dmultinom_$x[x]$value <- x_values[x]
  )
  #' @description dmultinom should error out when there is a dimension mismatch.
  expect_error(
    object = dmultinom_$evaluate(),
    regexp = "MultinomialLPDF: Vector index out of bounds. The dimension of the observed vector of size 9 and the expected vector is of size 10"
  )
  clear()
})
