# Instructions ----
#' This file follows the format generated by FIMS:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?FIMS:::use_gtest_template` for more
#' information. Every test should have a @description tag, which can span
#' multiple lines, that will be used in the bookdown report of the results from
#' {testthat}.

# use_*_template ----
## setup ----
# Set up for all of the use_*_template functions in the following section.

# This is a meta-test that creates a temporary package structure to test the use
# of the `use_gtest_template()` and `use_testthat_template()` functions. It works
# inside the temporary environment created by the test file. However, it does not
# work when using the reporting tool {testdown} because it cannot
# find the path back to the original test file in the GitHub Actions runner. This
# leads to errors like: In normalizePath(attr(result$srcref, "srcfile")$filename) :
# path[1]="test-use-test-template.R": No such file or directory. To fix the issue,
# we need to skip the test file when generating {testdown} reports.
if (Sys.getenv("INPUT_TESTDOWN") == "true") {
  #' @description Skip the test in {testdown} reports generation.
  skip("Skipping test in {testdown} reports generation.")
}

load(test_path("fixtures", "integration_test_data.RData"))


## IO correctness ----

# Load sample data
data("data1")
# Prepare data for FIMS model
data_4_model <- FIMSFrame(data1)

# Create parameters
default_parameters <- data_4_model |>
  create_default_configurations() |>
  create_default_parameters(data = data_4_model)

test_that("`log_obs_error scalar` works with correct inputs", {
  #' @description Test that `log_obs_error` works when it is a fixed scalar.

  parameters_4_model <- default_parameters |>
    tidyr::unnest(cols = data) |>
    # remove all but one log_obs_sd initial values for Fleet1
    dplyr::filter(
      !(fleet_name == "fleet1" & label == "log_sd" & time > 1) |
        is.na(fleet_name == "fleet1" & label == "log_sd" & time > 1)
    )

  test_fit <- parameters_4_model |>
    initialize_fims(data = data_4_model) |>
    fit_fims(optimize = FALSE)

  json_estimates <- reshape_json_estimates(test_fit@model_output)

  log_sd_input <- parameters_4_model |>
    dplyr::filter(fleet_name == "fleet1" & label == "log_sd") |>
    dplyr::select(value)

  log_sd_output <- json_estimates |>
    dplyr::filter(module_id == 1 & !is.na(log_sd_values)) |>
    dplyr::select(log_sd_values) |>
    as.vector()

  for (i in seq_along(log_sd_output$log_sd_values)) {
    expect_equal(log_sd_input$value, log_sd_output$log_sd_values[i])
  }

  #' @description Test that `log_obs_error` works when it is an estimated scalar.

  # turn on estimation for log_sd
  parameters_4_model <- parameters_4_model |>
    dplyr::mutate(estimation_type = ifelse(fleet_name == "fleet1" &
      label == "log_sd",
    "fixed_effects", estimation_type
    ))

  test_fit <- parameters_4_model |>
    initialize_fims(data = data_4_model) |>
    fit_fims(optimize = FALSE)

  json_estimates <- reshape_json_estimates(test_fit@model_output)

  log_sd_input <- parameters_4_model |>
    dplyr::filter(fleet_name == "fleet1" & label == "log_sd") |>
    dplyr::select(value)

  log_sd_output <- json_estimates |>
    dplyr::filter(module_id == 1 & !is.na(log_sd_values)) |>
    dplyr::select(log_sd_values) |>
    as.vector()

  for (i in seq_along(log_sd_output$log_sd_values)) {
    expect_equal(log_sd_input$value, log_sd_output$log_sd_values[i])
  }
})


## Error handling ----
test_that("`log_sd` returns correct error messages when wrong dimensions", {
  #' @description Test that returns correct error message when log_sd is too short.
  #' The error is caught in initialize_modules, not in C++.
  parameters_4_model <- default_parameters |>
    tidyr::unnest(cols = data) |>
    # change log_sd input length to size 4
    dplyr::filter(
      !(fleet_name == "fleet1" & label == "log_sd" & time > 4) |
        is.na(fleet_name == "fleet1" & label == "log_sd" & time > 4)
    )

  expect_error(
    {
      test_fit <- parameters_4_model |>
        initialize_fims(data = data_4_model) |>
        fit_fims(optimize = FALSE)
    },
    regexp = "The size of `log_sd` does not match"
  )

  #' @description Test that returns correct error message when log_sd is too long.
  #' The error should be caught in initialize_modules, not in C++.
  parameters_4_model <- default_parameters |>
    tidyr::unnest(cols = data) |>
    # add an extra log_sd observation
    dplyr::add_row(
      fleet_name = "fleet1",
      label = "log_sd",
      value = -4.61
    )

  expect_error(
    {
      test_fit <- parameters_4_model |>
        initialize_fims(data = data_4_model) |>
        fit_fims(optimize = FALSE)
    },
    regexp = "The size of `log_sd` does not match"
  )
})


## Error handling ----
test_that("`log_Fmort` returns correct error messages when wrong dimensions", {
  #' @description Test that returns correct error message when log_Fmort is too short.
  #' The error should be caught in initialize_modules, not in C++.
  parameters_4_model <- default_parameters |>
    tidyr::unnest(cols = data) |>
    # change log_Fmort input length to size 4
    dplyr::filter(
      !(fleet_name == "fleet1" & label == "log_Fmort" & time > 4) |
        is.na(fleet_name == "fleet1" & label == "log_Fmort" & time > 4)
    )

  expect_error(
    {
      test_fit <- parameters_4_model |>
        initialize_fims(data = data_4_model) |>
        fit_fims(optimize = FALSE)
    },
    regexp = "log_Fmort size mismatch.Fleet log_Fmort"
  )

  #' @description Test that returns correct error message when log_Fmort is too long.
  #' The error should be caught in initialize_modules, not in C++.
  parameters_4_model <- default_parameters |>
    tidyr::unnest(cols = data) |>
    # add an extra log_Fmort observation
    dplyr::add_row(
      fleet_name = "fleet1",
      label = "log_Fmort",
      value = -3,
      module_name = "Fleet"
    )

  expect_error(
    {
      test_fit <- parameters_4_model |>
        initialize_fims(data = data_4_model) |>
        fit_fims(optimize = FALSE)
    },
    regexp = "Fleet log_Fmort size mismatch"
  )
})
