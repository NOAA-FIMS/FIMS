// Instructions ----
// This file follows the format generated by FIMS:::use_gtest_template().
// Necessary tests include input and output (IO) correctness [IO
// correctness], edge-case handling [Edge handling], and built-in errors and
// warnings [Error handling]. See `?FIMS:::use_gtest_template` for more
// information. Every test should have a description comment.
// More assertion macros provided by GoogleTest can be found at 
// https://google.github.io/googletest/reference/assertions.html.

#include "gtest/gtest.h"
// Include the header file for the function being tested
// For example, if testing the `evaluate` member function of the 
// `LogisticSelectivity` class, include the corresponding header in the test 
// file `tests/gtest/test_population_dynamics_selectivity_logistic.cpp`:
// #include "population_dynamics/selectivity/functors/logistic.hpp"
#include "utilities/fims_json.hpp"
// Include additional headers as needed
// For example, include <iostream> to use `std::cerr` and `std::cout`:
// #include <iostream>

namespace
{
  // JsonParser_WriteToFile 
  // IO correctness
  
  // Edge handling 
  
  // Error handling
  TEST(JsonParser_WriteToFile, CaptureError) {
    // Setup 
    // Load or prepare any necessary data for testing

    // Brings the JsonParser and JsonValue classes from the fims namespace into 
    // the local scope. This allows you to write 'JsonParser' instead of 
    // 'fims::JsonParser' in the code below.
    using fims::JsonParser;
    using fims::JsonValue;
    
    // Create an instance of JsonParser and a JSON value holding the number 42
    JsonParser parser;
    JsonValue value(42);

    // Set up a string variable for a bad file path
    // Note the test will fail if the path is just a non-existent file (e.g., 
    // std::string bad_path = "nonexistent_file.json";), because on most systems, 
    // if you try to open a file for writing in a directory that exists and you 
    // have write permissions, the file will be created if it does not exist.
    std::string bad_path = "bad_path/nonexistent_file.json";

    // Redirect std::cerr to capture error messages
    // Create a stringstream to capture output
    std::stringstream captured_cerr;
    // Save the old buffer and redirect std::cerr to captured_cerr
    // captured_cerr.rdbuf() is an in-memory stream, and it returns a pointer to 
    // its internal buffer. Internal buffer is a block of memory used to 
    // temporarily store data before it is written.
    std::streambuf* old_cerr = std::cerr.rdbuf(captured_cerr.rdbuf());

    // Call the WriteToFile function under test; should print an error to 
    // std::cerr if file can't be opened
    parser.WriteToFile(bad_path, value);

    // Restore std::cerr to its original state
    std::cerr.rdbuf(old_cerr);

    // Assert that the captured error output matches the expected error message
    EXPECT_EQ(
      // Get the captured error output as a string
      captured_cerr.str(), 
      "Error: Unable to open file bad_path/nonexistent_file.json for writing.\n"
    );
  }

}
