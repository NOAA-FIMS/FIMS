---
title: "FIMS Path: Growth (VonBertalanffy)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FIMS Path: Growth (VonBertalanffy)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{css, echo=FALSE}
.rchunk {
  border: solid #2e75b6;
}
.rcppchunk {
  border: solid #c55a11;
}
.fimschunk {
  border: solid #548235;
}
.infochunk {
  border: solid #262626;
}
```

<style type="text/css">
code span.co{
  color: #8c8c8c;
}
</style>

This vignette describes the path from R to C++ for the **Growth v1** module using the fixed-parameter **VonBertalanffy** implementation. The goal is to show how values set in R propagate through the Rcpp interface and into the C++ core where length-at-age (LAA), SD LAA, and weight-at-age (WAA) are computed and cached for downstream use. The VonB parameterization used here is the SS3-style **two-reference-age** form (`L1`, `L2` at `age_L1`, `age_L2`), sometimes referred to informally as a "two-point" or "length-at-two-ages" parameterization.

## Modules in R

Growth parameters are created through the standard configuration/parameter workflow. The Growth module type is switched to `VonBertalanffy`, default parameters are created, and optional overrides are applied.

```{r, class.source = "rchunk", eval = FALSE}
library(FIMS)
data("data1")
fims_frame <- FIMSFrame(data1)

# Switch Growth to VonBertalanffy
config <- create_default_configurations(data = fims_frame) |>
  tidyr::unnest(cols = data)
config$module_type[config$module_name == "Growth"] <- "VonBertalanffy"
config <- tidyr::nest(config, .by = c(model_family, module_name, fleet_name))

# Create default parameters (Growth defaults live here)
params <- create_default_parameters(configurations = config, data = fims_frame) |>
  tidyr::unnest(cols = data)

# Optional: override Growth values
params <- dplyr::rows_update(
  params,
  tibble::tibble(
    module_name = "Growth",
    label = c("L1", "L2", "K", "a_wl", "b_wl", "age_L1", "age_L2"),
    value = c(8, 60, 0.2, 1e-5, 3.0, 1, 12)
  ),
  by = c("module_name", "label")
)

# Initialize Growth module (usually happens inside initialize_fims)
growth <- FIMS:::initialize_growth(parameters = params, data = fims_frame)
```

The defaults for growth parameters (including `age_L1`, `age_L2`, and `SDgrowth`) are created in `R/create_default_parameters.R`. Missing `age_L1`/`age_L2` values are treated as an error during initialization so defaults remain centralized.

## Rcpp Interface

The Growth Rcpp interface exposes a `VonBertalanffyGrowth` class with parameter fields. These are registered in `src/fims_modules.hpp` and implemented in `inst/include/interface/rcpp/rcpp_objects/rcpp_growth.hpp`.

```{Rcpp, class.source = "rcppchunk", eval = FALSE}
Rcpp::class_<VonBertalanffyGrowthInterface>("VonBertalanffyGrowth")
  .constructor()
  .field("L1", &VonBertalanffyGrowthInterface::L1)
  .field("L2", &VonBertalanffyGrowthInterface::L2)
  .field("K",  &VonBertalanffyGrowthInterface::K)
  .field("age_L1", &VonBertalanffyGrowthInterface::age_L1)
  .field("age_L2", &VonBertalanffyGrowthInterface::age_L2)
  .field("a_wl", &VonBertalanffyGrowthInterface::a_wl)
  .field("b_wl", &VonBertalanffyGrowthInterface::b_wl)
  .field("SDgrowth", &VonBertalanffyGrowthInterface::SDgrowth)
  .field("n_ages", &VonBertalanffyGrowthInterface::n_ages)
  .method("get_id", &VonBertalanffyGrowthInterface::get_id)
  .method("evaluate", &VonBertalanffyGrowthInterface::evaluate);
```

These fields mirror the fixed parameters used by the C++ growth model: `L1`, `L2`, `K`, `age_L1`, `age_L2`, `a_wl`, `b_wl`, and `SDgrowth`.

## C++ Core

Growth v1 is implemented as a small stack of C++ types:

- **Functor:** `VonBertalanffyGrowth` in `inst/include/population_dynamics/growth/functors/von_bertalanffy.hpp`  
- **Model:** `GrowthModel` in `inst/include/population_dynamics/growth/growth_model.hpp`  
- **Products:** `GrowthProducts` in `inst/include/population_dynamics/growth/growth_products.hpp`

The functor defines the core formula:

```{Rcpp, class.source = "fimschunk", eval = FALSE}
// file: inst/include/population_dynamics/growth/functors/von_bertalanffy.hpp
// L(a) = L1 + (L2 - L1) * (1 - exp(-K * (a - A1))) /
//        (1 - exp(-K * (A2 - A1)))
```

The model wraps the functor and computes cached products (mean LAA, SD LAA, mean WAA) across years, ages, and sexes. The data structures are already dimensioned as `(year, age, sex)` even though v1 uses a single year and a single sex:

```{Rcpp, class.source = "fimschunk", eval = FALSE}
// file: inst/include/population_dynamics/growth/growth_model.hpp
GrowthModel::Prepare() {
  // validate parameters
  // compute LAA/SD/WAA and store in GrowthProducts
}
```

## Wiring into Information and Population

Growth objects are stored in `Information` and attached to populations. The adapter bridges the product-based model to the legacy `evaluate(age)` interface expected downstream.

```{Rcpp, class.source = "infochunk", eval = FALSE}
// file: inst/include/common/information.hpp
if (std::shared_ptr<fims_popdy::VonBertalanffyGrowthModelAdapter<Type>>
        adapter = std::dynamic_pointer_cast<
            fims_popdy::VonBertalanffyGrowthModelAdapter<Type>>(p->growth)) {
  adapter->Initialize(p->n_years, p->n_ages, 1);
  adapter->SetAgeOffset(min_age);
}
```

The adapter uses cached WAA:

```{Rcpp, class.source = "fimschunk", eval = FALSE}
// file: inst/include/population_dynamics/growth/growth_model_adapter.hpp
return p.MeanWAA(0, age_index, 0);
```

Population holds a generic growth pointer:

```{Rcpp, class.source = "fimschunk", eval = FALSE}
// file: inst/include/population_dynamics/population/population.hpp
std::shared_ptr<fims_popdy::GrowthBase<Type>> growth;
```

This keeps the population code generic and allows new growth variants to plug in without changing downstream logic. The wiring also leaves room for future expansion to sex-specific or time-varying growth by populating `n_sexes` and `n_years` when those models are added; the current adapter initialization passes `n_sexes = 1` and uses population ages and age offsets for correct indexing.

## Summary

Growth v1 is a fixed-parameter VonBertalanffy implementation with a clean R → Rcpp → C++ pipeline. Parameters are defined in R defaults, passed through Rcpp, and used in C++ to compute LAA, SD LAA, and WAA products. The growth adapter exposes WAA through `evaluate(age)` so existing CAA/population code can consume it without structural changes.
